# **Community Detection**

# Evolutionary Algorithms vs K-Means

Report by Andrei Popovici, Alexandra Lakatos

![](RackMultipart20200806-4-bntdf7_html_a0243959dbc46b8f.png)

# ![](RackMultipart20200806-4-bntdf7_html_350121487af119b8.png)

Image taken from [here](https://medium.com/@figarrikeisha/community-detection-of-my-network-d0977bfdee4e)

# I. Introduction

The scientific problem that we tried to solve is known in the literature as &quot;Community Detection&quot;. This problem has various real life use cases such as: detecting dangerous communities in social networks, targeting ads to specific groups of people, and many more. More specifically, we tried to solve the non-overlapping communities version of the problem.

We did experiments using two popular algorithms which will be described in the next chapter:

- Evolutionary algorithm
- K-Means clustering

# II. Our methods

## K-Means Clustering

K-Means Clustering algorithm is a technique that aims to partition _n_ observations into _k_ clusters. It is usually used on multi-dimensional vectors, but for the purpose of this project we wrote a _discrete version of K-Means for graphs_.

A possible pseudocode for this algorithms goes like this:

1. initialize random vector centroids
2. attribute each point to the closest centroid
3. for no\_generations
  1. compute the new centroids
  2. attribute each point to the closest centroid

For the purpose of _Graph K-Means algorithm_ the initial random centroids are random nodes in the graph.

Step 2. is implemented using a _Breadth First Search (BFS)_ in which, in the beginning, every centroid is inserted in a queue. Then, while the queue is not empty, we take the first node, _x_, from the queue. Each of its neighbours, that was not previously assigned to any cluster, will be assigned to the cluster of the _x_ node. This is the same as step 3.2.

To compute the new centroids mentioned in step3.1. we first have to define what a centroid is. A centroid is a node for which the maximum distance to another node in the cluster is minimal. With this definition in mind, we use another _BFS_ to compute the minimum distance from each node to every other node in the same cluster. The node which has the minimal longest distance is the new centroid of that cluster.

### Graphical Explanation:

First Iteration:

![](RackMultipart20200806-4-bntdf7_html_f0ca7b69348d1008.png) ![](RackMultipart20200806-4-bntdf7_html_b60050753ed3a050.png) ![](RackMultipart20200806-4-bntdf7_html_bca2aeb107d27fdf.png)

Second Iteration:

![](RackMultipart20200806-4-bntdf7_html_1997fc7fd5356878.png) ![](RackMultipart20200806-4-bntdf7_html_278ff35863608fb7.png) ![](RackMultipart20200806-4-bntdf7_html_5a880b833ffed37a.png)

## Evolutionary Algorithm

1. **Representation**
 The individuals of the populations have been represented using locus-based adjacency representation. This means that an individual consists of _n_ genes _g __1__ , ..., g__n_ and each gene can take an allele value in the range _{1, ..., n}_. A value _j_ assigned to the _i_th gene is interpreted as a link between the nodes _i_ and _j_ of the set of vertices _V_ of the network.

1. **Algorithm**

The algorithm used is the following, having as parameters the number of individuals from the population, the number of generations and the mutation probability:

1. generate initial population with n individuals
2. evaluate individuals
3. for no\_generations
  1. select parents for the next generations
  2. generate offspring by applying crossover
  3. mutate offsprings
  4. evaluate offsprings
  5. select the next generation

1. **Selection**
 The parents which will create the next generation of offsprings have been chosen randomly out of all the individuals from the population. For the next generation, we select the first _n_ best individuals among the old generation and the newly created offsprings,, where _n_ is the initial number of the population.
2. **Crossover**

The crossover operator used is _standard uniform crossover._ In order for this to be performed a binary mask of length equal to the number of nodes is randomly created and an offspring is generated by selecting from the first parent the genes where the mask is 0, and from the second parent the genes where the mask is 1.

1. **Mutation**

Mutation operator is applied over each individual with a given probability. Each gene of the chromosome has the chance to be mutated. Its new allele value is randomly chosen among the neighbours of the node representing the gene.

#

#

# III. Fitness Function

We used _modularity (Q)_ [6] as a fitness function. It can be defined in the following way:

![](RackMultipart20200806-4-bntdf7_html_86f05b108098bb4b.gif)

Where _L(C __i__ , C __i__ )_ is the number of edges that are inside the community _i_. _L(C __i__ , V)_ is the total number of edges that are connected to the current community.

This function is used by the scientific community because it takes into consideration both the number of connections inside each community and it penalises every edge that is connected to that community. This treats the case in which an algorithm says that the whole graph is a community.

# IV. Our results

To test the performance of our algorithms we used two real-world datasets:

1. [_Facebook data was collected from survey participants_](https://snap.stanford.edu/data/ego-Facebook.html) (4039 nodes, 88234 edges) [3]
2. [_Zachary&#39;s Karate Club_](http://www-personal.umich.edu/~mejn/netdata/) [4]

## K-Means Clustering

This algorithm shows much **better results on bigger datasets** compared to the EA implementation. It is also **much faster** on both datasets. However, on small datasets it performs worse.

According to [5], the best results for _[Zachary&#39;s Karate Club](http://www-personal.umich.edu/~mejn/netdata/karate.zip) dataset_ are about ~0.41. The following results are on this dataset:

| No\_starts: 2500 No\_clusters: 2 | No\_starts: 2500 No\_clusters: 3 | No\_starts: 2500 No\_clusters: 10 | No\_starts: 2500 No\_clusters: 20 |
| --- | --- | --- | --- |
| BEST: 0.320513 AVG: 0.244005 | BEST: **0.375372** AVG: **0.264226** | BEST: 0.291913 AVG: 0.19077 | BEST: 0.143573 AVG: 0.0874909 |

For 2500 starts of the algorithm, the total time is **0.5 seconds.**

These results are on the _Facebook dataset:_

| No\_starts: 20 No\_clusters: 2 | No\_starts: 20 No\_clusters: 5 | No\_starts: 20 No\_clusters: 10 | No\_starts: 20 No\_clusters: 20 |
| --- | --- | --- | --- |
| BEST: 0.320513 AVG: 0.244005 RUN\_TIME: 120s | BEST: 0.663135 AVG: 0.498463 RUN\_TIME: 75s | BEST: **0.729996** AVG: 0.591778 RUN\_TIME: 45s | BEST: 0.705235 AVG: **0.671849** RUN\_TIME: **25s** |

For 20 starts of the algorithm, the total time taken is presented in the above table

## Evolutionary Algorithm

The results obtained refer to 2 instances, on which several tests were performed: one contains 34 nodes and 78 edges between these nodes and the other, provided by Facebook, contains a number of 4039 nodes with 88234.

For the instance with 34 nodes, the evolutionary algorithm was tested on 4 different combinations of values for the parameters and the results are reported in the following table:

| No\_population: 500No\_generations: 50 | No\_population: 500No\_generations: 100 | No\_population: 1000No\_generations: 50 | No\_population: 1000No\_generations: 100 |
| --- | --- | --- | --- |
| BEST: 0.401216 AVG: 0.396363 | BEST: 0.401216 AVG:0.401081 | BEST: **0.401874** AVG: 0.400916 | BEST: **0.401874** AVG: **0.401874** |

According to [1], a value over 0.3 of the modularity fitness function indicates a good community division. Therefore, the evolutionary algorithm results may be interpreted as good results on the instance with 34 nodes. They are also close to the State of the Art results presented in by K. Ozturk et. al in [5], which are ~_0.419_.

The results from the table indicates the fact that the increase in both the number of individuals from the population and the number of generations will produce a better community division. However, any numbers over 1000 for the population and 100 for the generations will no longer produce better results.

The problem with the Evolutionary Algorithm comes from the instance with 4039 nodes. The modularity fitness function registered the best value ~0.03 or ~0.04, which is an indicator of the fact an Evolutionary Algorithm does not perform well on a graph with a large number of vertices and edges. Moreover, it takes too much time for the algorithm to run on such an instance, therefore it is difficult to perform many tests on it. A number of 10 tests could be run on this instance with 100 individuals in the population and 30 generations. Both the average and best result may be rounded to 0.04.

# V. Conclusion

We observed the fact that the two methods implemented in our project report different results for the two datasets. For the facebook instance, the K-Means algorithm greatly outperforms the Evolutionary Algorithm both as running time and results: 0.73 vs 0.04 modularity and 45 seconds vs 76 second (for 50 generations and population of 100). However, for the _ZKH dataset_ the situation is a bit different, the EA method coming at the top (still at greater running time).

Our belief is that had we implemented other heuristics, such as a better method for selecting the parents and the individuals for the next generations or choosing different variation operators, the modularity function still would not reach an acceptable value of ~0.3 for the _Facebook dataset_.

**VI. References**

[1] Clara Pizzuti, Evolutionary Computation for Community Detection in Networks: a Review, IEEE Transactions on Evolutionary Computation, vol. X, no. X, X 2017,

[2] Andrew Ng, Introduction to Machine Learning, Coursera

[https://www.coursera.org/learn/machine-learning/lecture/93VPG/k-means-algorithm](https://www.coursera.org/learn/machine-learning/lecture/93VPG/k-means-algorithm)

[3] Jure Leskovec and Andrej Krevl, {SNAP Datasets}: {Stanford} Large Network Dataset Collection, [http://snap.stanford.edu/data](http://snap.stanford.edu/data)

[4] W. W. Zachary, An information flow model for conflict and fission in small groups, Journal of Anthropological Research 33, 452-473 (1977)

[5] K. Ozturk, An Evolutionary Approach for Detecting Communities in Social Networks

[6] Newman M.E.J. Girvan, M. Finding and evaluating community structure in networks. Physical Review E, 2(69), 2004

![](RackMultipart20200806-4-bntdf7_html_d7dec09130297fd1.png)
