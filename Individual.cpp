#include "Individual.h"

// locus based representation is used for an individual
void Individual::generate_neighbour_vector(const Graph &graph) {
    int no_nodes = graph.size();

    chosen_neighbour_vector_.resize(no_nodes);

    for (int i = 0; i < no_nodes; i++) {
        const std::vector<int> &current_node_neighbours = graph[i];
        int no_neighbours = current_node_neighbours.size();

        if (no_neighbours > 0) {
            int random_neighbour_index = rand() % no_neighbours;

            chosen_neighbour_vector_[i] = current_node_neighbours[random_neighbour_index];
        } else {
            chosen_neighbour_vector_[i] = i;
        }
    }
}

Individual::Individual(const Graph &graph) {
    generate_neighbour_vector(graph);
}

// create an offspring from two parents i.e. perform crossover between two parents
// here, a binary mask of length equal to the number of nodes is randomly
// created, and an offspring is generated by selecting from the
// first parent the genes where the mask is 0, and from the second
// parent the genes where the mask is 1.
Individual::Individual(const Individual &individual1, const Individual &individual2) {
    int no_chromosomes = individual1.size();

    for (int i = 0; i < no_chromosomes; i++) {
        int bit = rand() & 1;

        if (bit == 0) {
            chosen_neighbour_vector_.push_back(individual1[i]);
        } else {
            chosen_neighbour_vector_.push_back(individual2[i]);
        }
    }
}

std::ostream &operator<<(std::ostream &os, const Individual &individual) {
    for (int i : individual.chosen_neighbour_vector_) {
        os << i << " ";
    }

    return os;
}

int Individual::size() const {
    return chosen_neighbour_vector_.size();
}

int Individual::operator[](const int index) const {
    return chosen_neighbour_vector_[index];
}

bool Individual::operator<(const Individual &other_individual) const {
    return fitness_ < other_individual.fitness_;
}

// mutate each chromosome of the individual with a given probability;
// for each chromosome, a random new neighbour is selected
// and assigned as the new allele value of that chromosome
void Individual::mutate(const Graph &graph, double mutation_probability) {
    for (int i = 0; i < chosen_neighbour_vector_.size(); i++) {
        double current_mutation_probability = ((double) rand() / (RAND_MAX));

        if (current_mutation_probability < mutation_probability) {
            const std::vector<int> &current_node_neighbours = graph[i];

            int random_neighbour_index = rand() % current_node_neighbours.size();
            int new_neighbour = current_node_neighbours[random_neighbour_index];

            chosen_neighbour_vector_[i] = new_neighbour;
        }
    }
}

double Individual::get_fitness() const {
    return fitness_;
}

const std::vector<int> &Individual::get_chosen_neighbour_vector() const {
    return chosen_neighbour_vector_;
}

bool Individual::operator!=(const Individual &other_individual) const {
    return chosen_neighbour_vector_ != other_individual.chosen_neighbour_vector_;
}
